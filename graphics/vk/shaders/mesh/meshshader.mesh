#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_mesh_shader : require

#include "meshshader.include.glsl"

layout(local_size_x = 128) in;
layout(triangles, max_vertices = 64, max_primitives = 126) out;

layout(set = 0, binding = 0) uniform SceneData{
    mat4 worldMatrix;
} sceneData;

layout(set = 0, binding = 3) uniform ViewMatrix {
    mat4 viewMatrix;
};

layout(set = 0, binding = 4) readonly buffer PositionBuffer {
    vec4 vertices[];
};

layout(set = 0, binding = 5) readonly buffer MeshletBuffer {
    Meshlet meshlets[];
};

layout(set = 0, binding = 6) readonly buffer MeshletVertexBuffer {
    uint meshletVertices[];
};

layout(set = 0, binding = 7) readonly buffer MeshletPrimitivesBuffer {
    uint meshletPrimitives[];
};

layout(push_constant) uniform PushConstants {
    mat4 mvp;
} pushConstants;

layout(location = 0) out VertexOutput {
    vec3 fragNormal;
} vertexOutputs[];

taskPayloadSharedEXT Payload payload;

void main() {
    uint gtid = gl_LocalInvocationID.x;
    uint gid = gl_WorkGroupID.x;
    Meshlet meshlet = meshlets[payload.meshletPrimitives[gid]];

    SetMeshOutputsEXT(meshlet.vertex_count, meshlet.triangle_count);

    if (gtid < meshlet.triangle_count) {
        uint packed = meshletPrimitives[meshlet.triangle_offset + gtid];
        uint i0 = (packed      ) & 0xFF;
        uint i1 = (packed >> 8 ) & 0xFF;
        uint i2 = (packed >> 16) & 0xFF;

        gl_PrimitiveTriangleIndicesEXT[gtid] = uvec3(i0, i1, i2);
    }

    if (gtid < meshlet.vertex_count) {
        uint vertexIndex = meshletVertices[meshlet.vertex_offset + gtid];
        gl_MeshVerticesEXT[gtid].gl_Position = sceneData.worldMatrix * pushConstants.mvp * vertices[vertexIndex];

        vertexOutputs[gtid].fragNormal = vec3(float(gid & 1), float(gid & 3) / 4, float(gid & 7) / 8);
    }
}