#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require

#include "tiled_shading.glsl"

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std430, set = 0, binding = 0) buffer writeonly frustumBuffer {
    LightVisibility visibleLightIndices[];
};

layout(push_constant) uniform PushConstants {
    mat4 inverseVp;
    ivec2 viewportSize;
} pushConstants;

vec3 ScreenSpaceToViewSpace(vec2 screenSpace) {
    vec2 ndc = screenSpace / vec2(pushConstants.viewportSize);
//    vec4 clipSpace = vec4(2.0 * vec2(ndc.x, 1.0f - ndc.y) - 1.0, -1.0, 1.0);
    vec4 clipSpace = vec4(2.0 * ndc - 1.0, -1.0, 1.0);
    vec4 view = vec4(pushConstants.inverseVp) * clipSpace;
    view /= view.w;

    return view.xyz;
}

vec3 LineIntersectionWithZPlane(vec3 lineStart, vec3 lineEnd, float z) {
    float t = (z - lineStart.z) / (lineEnd.z - lineStart.z);
    return lineStart + (lineEnd - lineStart) * t;
}

void main() {
    uint tileIndex = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_NumWorkGroups.x + gl_GlobalInvocationID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y;
    vec2 tileSize = vec2(pushConstants.viewportSize) / gl_NumWorkGroups.xy;

    vec2 workGroup = vec2(gl_WorkGroupID.xy);

    vec3 minTile = ScreenSpaceToViewSpace(workGroup * tileSize);
    vec3 maxTile = ScreenSpaceToViewSpace(workGroup * tileSize + tileSize);

    vec2 workGroupRatio = vec2(gl_WorkGroupID.z / gl_NumWorkGroups.z, (gl_WorkGroupID.z + 1) / gl_NumWorkGroups.z);
    vec2 planes = vec2(pow(10000.0f, workGroupRatio.x), pow(10000.0f, workGroupRatio.y)) * 0.1f;

    vec3 eye = vec3(0);
    vec3 minPointNear = LineIntersectionWithZPlane(eye, minTile, planes.x);
    vec3 maxPointNear = LineIntersectionWithZPlane(eye, maxTile, planes.x);
    vec3 minPointFar = LineIntersectionWithZPlane(eye, minTile, planes.y);
    vec3 maxPointFar = LineIntersectionWithZPlane(eye, maxTile, planes.y);

    visibleLightIndices[tileIndex].minPoint = vec4(min(minPointNear, minPointFar), 0.0);
    visibleLightIndices[tileIndex].maxPoint = vec4(max(maxPointNear, maxPointFar), 0.0);
}