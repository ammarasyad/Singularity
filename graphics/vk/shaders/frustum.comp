#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require

#include "tiled_shading.glsl"

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std430, set = 0, binding = 0) buffer writeonly frustumBuffer {
    LightVisibility visibleLightIndices[];
};

layout(push_constant) uniform PushConstants {
    mat4 inverseVp;
    ivec2 viewportSize;
} pushConstants;

f16vec3 ScreenSpaceToViewSpace(vec2 screenSpace) {
    vec2 ndc = screenSpace / pushConstants.viewportSize;
//    vec4 clipSpace = vec4(2.0 * vec2(ndc.x, 1.0f - ndc.y) - 1.0, -1.0, 1.0);
    vec4 clipSpace = vec4(2.0 * ndc - 1.0, -1.0, 1.0);
    vec4 view = pushConstants.inverseVp * clipSpace;
    view /= view.w;

    return f16vec3(view.xyz);
}

f16vec3 LineIntersectionWithZPlane(f16vec3 lineStart, f16vec3 lineEnd, float16_t z) {
    float16_t t = (z - lineStart.z) / (lineEnd.z - lineStart.z);
    return lineStart + (lineEnd - lineStart) * t;
}

void main() {
    uint tileIndex = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_NumWorkGroups.x + gl_GlobalInvocationID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y;
    vec2 tileSize = vec2(pushConstants.viewportSize) / vec2(gl_NumWorkGroups.x, gl_NumWorkGroups.y);

    f16vec3 minTile = ScreenSpaceToViewSpace(vec2(gl_WorkGroupID.xy) * tileSize);
    f16vec3 maxTile = ScreenSpaceToViewSpace(vec2(gl_WorkGroupID.xy + 1) * tileSize);

    float16_t planeNear = float16_t(-0.1f * pow(10000.f, gl_WorkGroupID.z / float(gl_NumWorkGroups.z)));
    float16_t planeFar = float16_t(-0.1f * pow(10000.f, (gl_WorkGroupID.z + 1) / float(gl_NumWorkGroups.z)));

    f16vec3 minPointNear = LineIntersectionWithZPlane(f16vec3(0), minTile, planeNear);
    f16vec3 maxPointNear = LineIntersectionWithZPlane(f16vec3(0), maxTile, planeNear);
    f16vec3 minPointFar = LineIntersectionWithZPlane(f16vec3(0), minTile, planeFar);
    f16vec3 maxPointFar = LineIntersectionWithZPlane(f16vec3(0), maxTile, planeFar);

    visibleLightIndices[tileIndex].minPoint = vec4(min(minPointNear, minPointFar), 0.0);
    visibleLightIndices[tileIndex].maxPoint = vec4(max(maxPointNear, maxPointFar), 0.0);
}