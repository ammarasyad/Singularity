#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_16bit_storage : require

#include "tiled_shading.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0) buffer readonly lightUniform {
    uint lightCount;
    Light lights[];
};

layout(set = 0, binding = 1) buffer writeonly visibleLightBuffer {
    LightVisibility visibleLightIndices[];
};

layout(set = 0, binding = 2) uniform sampler2D depthSampler;

layout(set = 0, binding = 3) buffer readonly frustumBuffer {
    ViewFrustum frustum;
};

// TODO: Reduce this to below 128 bytes for maximum compatibility
layout(push_constant) uniform PushConstants {
    mat4 viewProjection;
    vec3 cameraPosition;
    ivec2 viewportSize;
} pushConstants;

shared uint visibleLightCount;

void main() {
    ivec2 tileId = ivec2(gl_WorkGroupID.xy);
    uint tileIndex = tileId.y * gl_WorkGroupSize.x + tileId.x;

    if (gl_LocalInvocationIndex == 0) {
        visibleLightCount = 0;
    }

    barrier();

    // TODO: Implement 2.5D light culling
    for (uint i = gl_LocalInvocationIndex; i < lightCount; i += gl_WorkGroupSize.x) {
        Light light = lights[i];
        f16vec3 lightPos = light.position.xyz;
        float16_t lightRadius = light.position.w;

        bool visible = true;
        for (int j = 0; j < 6; j++) {
            f16vec4 plane = f16vec4(frustum.planes[j]);
            float16_t distance = dot(plane.xyz, lightPos) + plane.w;
            if (distance < -lightRadius) {
                visible = false;
                break;
            }
        }

        if (visible) {
            uint localIndex = atomicAdd(visibleLightCount, 1);
            visibleLightIndices[tileIndex].indices[localIndex] = i;
        }
    }

    barrier();

    if (gl_LocalInvocationIndex == 0) {
        visibleLightIndices[tileIndex].count = min(visibleLightCount, MAX_LIGHTS);
    }
}