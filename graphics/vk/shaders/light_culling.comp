#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_16bit_storage : require

#include "tiled_shading.glsl"

#define LOCAL_SIZE_X 4
#define LOCAL_SIZE_Y 3
#define LOCAL_SIZE_Z 4

layout(local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y, local_size_z = LOCAL_SIZE_Z) in;

layout(set = 0, binding = 0) buffer readonly lightUniform {
    uint lightCount;
    Light lights[];
};

layout(std430, set = 0, binding = 1) buffer visibleLightBuffer {
    LightVisibility visibleLightIndices[];
};

layout(set = 0, binding = 2) uniform sampler2D depthSampler;

layout(push_constant) uniform PushConstants {
    mat4 viewMatrix;
} pushConstants;

bool SphereAABBIntersection(f16vec4 sphere, float16_t radius, f16vec3 aabbMin, f16vec3 aabbMax) {
    f16vec3 closestPointInAabb = clamp(sphere.xyz, aabbMin, aabbMax);
    f16vec3 distance = sphere.xyz - closestPointInAabb;
    return dot(distance, distance) <= radius * radius;
}

void main() {
    uint lightCount = visibleLightIndices.length();
    uint tileIndex = (gl_WorkGroupID.z * LOCAL_SIZE_Z + gl_LocalInvocationID.z) * gl_NumWorkGroups.x * LOCAL_SIZE_X * gl_NumWorkGroups.y * LOCAL_SIZE_Y
                   + (gl_WorkGroupID.y * LOCAL_SIZE_Y + gl_LocalInvocationID.y) * gl_NumWorkGroups.x * LOCAL_SIZE_X
                   + (gl_WorkGroupID.x * LOCAL_SIZE_X + gl_LocalInvocationID.x);

    visibleLightIndices[tileIndex].count = 0;

    for (uint i = 0; i < lightCount; i++) {
        f16vec4 sphere = f16vec4(pushConstants.viewMatrix * f16vec4(lights[i].position.xyz, 1.0hf));
        f16vec3 minPoint = visibleLightIndices[tileIndex].minPoint.xyz;
        f16vec3 maxPoint = visibleLightIndices[tileIndex].maxPoint.xyz;

        bool intersects = SphereAABBIntersection(sphere, lights[i].position.w, minPoint, maxPoint) && visibleLightIndices[tileIndex].count < MAX_LIGHTS;

        visibleLightIndices[tileIndex].indices[visibleLightIndices[tileIndex].count] = (mix(visibleLightIndices[tileIndex].indices[visibleLightIndices[tileIndex].count], i, intersects));
        visibleLightIndices[tileIndex].count += uint(intersects);
//        if (SphereAABBIntersection(sphere, lights[i].position.w, minPoint, maxPoint) && visibleLightIndices[tileIndex].count < MAX_LIGHTS) {
//            visibleLightIndices[tileIndex].indices[visibleLightIndices[tileIndex].count++] = i;
//        }
    }
}