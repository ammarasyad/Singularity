#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_debug_printf : enable

#include "tiled_shading.glsl"

layout(local_size_x = TILE_SIZE, local_size_y = TILE_SIZE) in;

layout(set = 0, binding = 0) buffer readonly lightUniform {
    uint lightCount;
    Light lights[];
};

layout(set = 0, binding = 1) buffer writeonly visibleLightBuffer {
    LightVisibility visibleLightIndices[];
};

layout(set = 0, binding = 2) uniform sampler2D depthSampler;

// TODO: Reduce this to below 128 bytes for maximum compatibility
layout(push_constant) uniform PushConstants {
    mat4 viewProjection;
    vec3 cameraPosition;
    ivec2 viewportSize;
} pushConstants;

shared ViewFrustum frustum;
shared float minDepth;
shared float maxDepth;
//shared uint depthMask;

shared uint visibleLightCount;

void main() {
    ivec2 tileId = ivec2(gl_WorkGroupID.xy);
    ivec2 tileNum = ivec2(gl_NumWorkGroups.xy);
    uint tileIndex = tileId.y * tileNum.x + tileId.x;

    if (gl_LocalInvocationIndex == 0) {
        minDepth = 0xFFFFFFFF;
        maxDepth = 0;
//        depthMask = 0;
        visibleLightCount = 0;

        for (int y = 0; y < TILE_SIZE; y++) {
            for (int x = 0; x < TILE_SIZE; x++) {
                vec2 location = (vec2(TILE_SIZE) * tileId + vec2(x, y)) / pushConstants.viewportSize;
                float depth = texture(depthSampler, location).r;
                minDepth = min(minDepth, depth);
                maxDepth = max(maxDepth, depth);
            }
        }

//        mat4 invViewProjection = inverse(pushConstants.viewProjection);

        vec2 ndcSizePerTile = (2.0 * vec2(TILE_SIZE)) / pushConstants.viewportSize;

        vec2 ndcPoints[4];
        ndcPoints[0] = vec2(-1.0) + tileId * ndcSizePerTile;
        ndcPoints[1] = vec2(ndcPoints[0].x + ndcSizePerTile.x, ndcPoints[0].y);
        ndcPoints[2] = ndcPoints[0] + ndcSizePerTile;
        ndcPoints[3] = vec2(ndcPoints[0].x, ndcPoints[0].y + ndcSizePerTile.y);

        vec4 temp;
        #pragma unroll
        for (int i = 0; i < 4; i++) {
            temp = pushConstants.viewProjection * vec4(ndcPoints[i], minDepth, 1.0);
            frustum.points[i] = temp.xyz / temp.w;

            temp = pushConstants.viewProjection * vec4(ndcPoints[i], maxDepth, 1.0);
            frustum.points[i + 4] = temp.xyz / temp.w;
        }

        vec3 tempNormal;
        #pragma unroll
        for (int i = 0; i < 4; i++) {
            tempNormal = normalize(cross(frustum.points[i] - pushConstants.cameraPosition, frustum.points[i + 1] - pushConstants.cameraPosition));
            frustum.planes[i] = vec4(tempNormal, -dot(tempNormal, frustum.points[i]));
        }

        tempNormal = normalize(cross(frustum.points[1] - frustum.points[0], frustum.points[3] - frustum.points[0]));
        frustum.planes[4] = vec4(tempNormal, -dot(tempNormal, frustum.points[0]));

        tempNormal = normalize(cross(frustum.points[7] - frustum.points[4], frustum.points[5] - frustum.points[4]));
        frustum.planes[5] = vec4(tempNormal, -dot(tempNormal, frustum.points[4]));
    }

    barrier();

    // TODO: Implement 2.5D light culling
    for (uint i = gl_LocalInvocationIndex; i < lightCount; i += gl_WorkGroupSize.x) {
        Light light = lights[i];
        vec3 lightPos = light.position.xyz;
        float lightRadius = light.position.w;

        bool visible = true;
        for (int j = 0; j < 6; j++) {
            vec4 plane = frustum.planes[j];
            float distance = dot(plane.xyz, lightPos) + plane.w;
//            debugPrintfEXT("Light %d: %f\n", i, distance);
            if (distance < -lightRadius) {
                visible = false;
                break;
            }
        }

        if (visible) {
            uint localIndex = atomicAdd(visibleLightCount, 1);
            visibleLightIndices[tileIndex].indices[localIndex] = i;
//            debugPrintfEXT("Light tile index: %d, localIndex: %d: %d\n", tileIndex, localIndex, i);
        }
    }

    barrier();

    if (gl_LocalInvocationIndex == 0) {
        visibleLightIndices[tileIndex].count = min(visibleLightCount, MAX_LIGHTS);
    }
}